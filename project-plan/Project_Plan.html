<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Project Plan</title>
<style>
    body {
        font-family: 'Arial', sans-serif;
        background-color: #f3ede1; /* Beige background */
        color: #444; /* Dark gray text */
        margin: 0;
        padding: 0;
    }
    
    h1, h2 {
        color: #6c533d; /* Brown headings */
        margin-top: 20px;
        position: relative;
    }
    h3 {
        color: #6c533d; /* Brown headings */
        margin-top: 10px;
        position: relative;
        margin-left: 10px;
        margin-bottom: 0px;
    }
    
    h2:after {
        content: '';
        position: absolute;
        bottom: -5px;
        left: 0;
        width: 50px;
        height: 2px;
        background-color: #6c533d; /* Brown underline */
    }
    
    p {
        line-height: 1.5;
        margin-bottom: 20px;
        margin-left: 15px;
        max-width: 61%;
    }

    li {
        max-width: 50%;
        color: #222; /* Dark gray text */
    }
        /* Styling hyperlinks */
    a {
        color: #6c533d; /* Brown color for hyperlinks */
        text-decoration: none; /* Remove underline by default */
        margin-left: 20px;
    }

    /* Hover effect for hyperlinks */
    a:hover {
        color: #b68f6e; /* Darker brown color on hover */
    }
    .todo {
        font-family: 'Courier New', monospace; /* Monospace font */
        color: #888; /* Muted color */
    }    
    .todo::before {
        content: "TODO:";
        background-color: #f7f7f7; /* Light gray background */
        padding: 5px; /* Padding around the comment */
        color: #555; /* Darker color for the label */
        font-weight: bold; /* Make the label bold */
        position: relative; /* Position the label absolutely */
        left: -10px; /* Adjust the position */
    }
    .optional {
        font-family: 'Courier New', monospace; /* Monospace font */
        color: #888; /* Muted color */
    }    
    .optional::before {
        content: "NICE-TO-HAVE:";
        background-color: #e6cc00; /* Light yellow background */
        padding: 5px; /* Padding around the comment */
        color: #555; /* Darker color for the label */
        font-weight: bold; /* Make the label bold */
        position: relative; /* Position the label absolutely */
        left: -10px; /* Adjust the position */
    }
    /* Example of a button style */
    .button {
        background-color: #d9b998; /* Light brown button */
        color: #fff;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        text-transform: uppercase;
        transition: background-color 0.3s ease;
    }
    
    .button:hover {
        background-color: #b68f6e; /* Darker brown on hover */
    }
    
    /* Cool fade effect */
    .fade-in {
        opacity: 0;
        animation: fadeInAnimation ease 1s forwards;
    }
    
    @keyframes fadeInAnimation {
        0% {
            opacity: 0;
        }
        100% {
            opacity: 1;
        }
    }
</style></head>
<body>
<h1>Relic Mercs Game Project Plan</h1>
<h2>Index Of Important Sections</h2>
<a href="#charValidation">Player Character Validation</a><br/>
<h2>What To Write In This Document</h2>
<p>
This document should contain descriptions of gameplay systems,
graphical effects, protocols, user interfaces, how they interact with eachother
and how they should be coded.
This should be a helpful resource to anybody working on this project,
mostly to see what to implement next and how.
</p>
<h2>What is this game?</h2>
<p>
A turn based role playing co-petetive game running in a browser.
The players take turns moving their characters on a map, encountering
events, using their character's skill to deal with the encounters and
making themselves more powerful.
The ultimate goal is to gather information and recover an ancient relic for a 
benefactor, while denying the relic to the other players.
</p>
<h2>How does it start?</h2>
<p>
The players, upon loading into the website, are greeted by a login screen
prompting a playername, player password and game password with a html form.
This associates them with an in-game character.
If they haven't been in the game yet, they are then redirected to
a character creation html form.
They fill in their character details, submit the form and it's validated
before spawning the player on the board and last in the turn order.
</p>
<h3 id="charValidation">Player Character Validation</h3>
<p>
<ul>
    <li>Usernames can't be duplicates</li>
    <li>The statistics on the character sheet need to adhere to the rules (prevent cheating)</li>
    <p class="todo"> What more do we need to validate?</p>
</ul>
</p>
<h2>The Game Interface</h2>
<ul>
    <li>A horizontal 3d planar map occupies the center of the screen and allows
        for camera panning and zooming (but no rotation, as it would only be confusing).</li>
    <li>The portraits for all the participants in the game should be shown
        in the top left, along with vital statistics.</li>
    <li>The player should be able to open their own and other character's statistics by
        clicking on the portraits.
        This should open a popup in the middle of the screen listing known statistics</li>
    <li>The player should have one button to see their Resources (covered later)</li>
    <li>The player should have one button to see their Reputations (covered later)</li>
</ul>
<h2>Core Gameplay Concepts</h2>
    <h3>Turn Order</h3>
    <p>The players take it in turns to play based on who joined the game first.</p>
    <p class="optional"> The game is configured with a minimum player count, it waits
        until there are that many people in the game, then it randomises the turn order </p>
    <h3>Player Statistics</h3>
    <p>The core loop of the game is that the players travel across the map, face random encounters and solve it with their skills.
    Any event they encounter will allow the player to solve it with at least one skill.
    Different skills are better for solving different situations, but applying different skills MIGHT yield different results-
    such as having cooler results on success despite having a lower success chance (though not as a rule).
    An event should present the player with a list of buttons presenting ways to solve the problem, also showing the success chance.
    The players will also need to keep track of their health and other core things like that.</p>
    <h3>Success Chance</h3>
    <ul>
        <li>Any encounter a player character faces has a certain difficulty for each different skill that
            can be applied to solve it, making some skills more or less applicable for an encounter.</li>
        <li>A success or failure on a skill check can have a range of possible outcomes.</li>
        <li>Before selecting an option, the player should be shown a chance of getting a neutral or better result for each skill check.</li>
        <li>The chance of success that the player is shown should scale with a wisdom chance, with lower wisdom characters
            getting less precise chances of success shown to them.</li>
    </ul>
    <h3>Action Points</h3>
    <p>The players will spawn in with a certain amount of Action points. Points are spent to travel and interact with locations.
    MAYBE random encounters should also use up action points when they happen.</p>
    <h3>Random Encounters</h3>
    <ul>
        <li>The player will spend action points to move around the map.</li>
        <li>At regular intervals, there will be a chance of enountering certain types of events.</li>
        <li>Encounters that the player could meet should all fall under tags e.g. BANDIT, or MONSTER or MERCHANT or MYSTICAL</li>
        <li>These chances should stack, so a player may need to deal with multiple encounters in one go. This also simplifies the math. </li>
        <li>You should be able to raise and lower chances of enountering events with certain tags based
            on a regional heatmap e.g. make the chance of enountering BANDIT type events in the MOUNTAINS higher or lower dynamically,
            where MOUNTAINS is an image denoting weight per pixel in the range of 0.0-1.0 (white->black)</li>
        <p class="optional">Split the pixel maps based on colour so a lot of maps can be compressed into one image, OR use an efficient format for 0.0-1.0</p>
        <li>Players should be able to gather information in game about what areas/regions have what type of events, and this
        should show variation between games.</li>
        <li>The chances of getting certain types of encounters in certain areas should change dynamically in response to other events and
        player actions e.g. killing bandits might slightly lower the odds of encountering BANDIT type events in the region.</li>
    </ul>
    <h3>Fixed Enounters</h3>
    <ul>
        <li>There should be locations in the game such as settlements where a person can travel and have the same encounter and options every time, such as visiting
            a shop to buy items.</li>
        <p class="optional">There should be a visible circular radius where an interaction with the fixed encounter can be initiated (but doens't NEED to be)</p>
        <li>Fixed encounter should NOT be random encounters i.e: go to a fixed location and then roll a random event.
            This should be managed by the heatmaps.</li>
    </ul>
    <h3>Player Resources</h3>
    <ul>
        <li>Players have a "Resources" button that shows their inventory and retinue.</li>
        <li>Certain items should be able to be equipped to modify chances of success with certain skills.</li>
        <p class="todo">How complex should the equipment system be? Clothing + held item, or something more complex?</p>
        <li>Items like consumables should be usable at any point and be consumed or have multiple uses.</li>
        <li>Retinue are followers or favours players can otherwise call on. Followers can provide passive modifications, or
            be "consumed" to aid the situation (or have multiple uses). They behave like items in this sense.
            Retinue could be like a knight's squire, or a favour owed by an organisation to carry out an attempted assassination
            on another player.</li>
        <li>Retinue are affected by reputation, so a follower could have a requirement of a specific player reputation or leave the player.</li>
        <p class="optional">Characters could have needs like hunger/thirst and what have you. May or may not be good. </p>
        <li>A trade/inventory menu is needed to handle items. Some resources need to be marked sellable and others not.</li>
        <p class="optional">Prices varying per region to create a simple economy simulation</p>
        <li>The resources a character has should be hidden from other players. All resources should have an alternate description
            that is public to other players, such as "A weapon" instead of "A sword", or "Ties to organisation X" instead of "A hired assassin".</li>
        <li>It should be a gameplay element to uncover what resources other players actually have.</li>
        <li>Information should be a resource. There should literally be an item a player can own that has the passive
            effect of displaying certain information that would otherwise be hidden. This should be trade-able with other players exclusively.</li>
    </ul>
    <h3>Player Reputation</h3>
        <ul>
            <li>Players have a separate reputation for each community of sentient beings in the game.</li>
            <li>Reputation can be modified by performing actions in fixed or random encounters that helps/hinders members of that group.</li>
            <li>Reputation will modify the outcome of events dramatically e.g. You encounter bandits, but you happen to have a great reputation
                with the town they come from so your chance to talk them down is increased drastically.</li>
            <li>It should be visible next to an action button if a reputation modifies the chance, and why.</li>
            <li>The area the player is in doesn't need to be tracked, since events are tied to the areas and communities to begin with.</li>
            <p class="optional">Maybe reputations could unlock or lock certain options in encounters too?</p>
            <li>Player reputations are not private.</li>
        </ul>
    <h3>Player On Player Interaction</h3>
        <ul>
            <li>Other players are a fixed encounter where you can fight or trade sellable resources.</li>
            <li>You should also be able to affect other players through encounters that have regional effects (e.g. a storm)</li>
            <li>You should be able to use resource to remotely affect other players e.g. A hired assassin</li>
            <p class="optional">What if players could team up into a party and win the game together? Make sure to consider this while designing, it could be BIG as a feature,
            or entirely unnecessary. </p>
            <li>A lot of resources should be usable during other player's turns. e.g. Hiring an assassin should make the player's next encounter be the assassin
                even during their turn. A very specific intervention I want to implement is the ability for enemies to sabotage skill checks
                of other players, turning a successful check into a failed one and having the victim be aware of the sabotage (or sometimes not?).
                All of this of course should be accomplished through the usage of character resources.</li>
            <p class="todo">Should you need to activate an antagonistic resource during the victim's turn and have it take
            effect immediately, or activate it any time, specify a target and have the game handle the logic?</p>
        </ul>
    <h3>Dying And Injuries</h3>
        <ul>
            <li>When a player loses a combat, they receive an injury, which is it's own unique system and shows up in the character sheet.
                A player's injuries is hidden information until uncovered.</li>
            <li>Injuries are sorted into light, heavy and critical. Different combat encounters will trigger different injury types.
                A specific injury is then chosen at random from the category, and can then be disabled or disable other specific injuries
                (e.g. losing leg cancels sprained ankle effects, and prevents getting it in the future).</li>
            <li>Injuries debuff a player until they are healed (if they can be healed at all).
                An injury has a fresh and a healed state, where the healed state can still affect the player.</li>
            <li>Each injury adds it's own amount of damage to a pool and the player dies at a certain threshold.</li>
            <li>Dead players observe the game, MAYBE respawn.</li>
            <p class="optional"> It might be cooler if the players could influence the game as ghosts, rerolling player checks or controlling
            animal companions and such.</p>
        </ul>
    <h3>Winning The Game</h3>
    <ul>
        <li>There are special story events that arise in sequence. It starts with the players spawning in, and having the option to ask about the
            relic in ANY settlement. No other relic-related encounters are active at this point.</li>
        <li>Only one settlement actually has the correct info, the other settlements point to that one.</li>
        <li>Asking at the correct settlement uncovers an information resource (see "Player Resources") that shows a fixed enounter in a random
            location with an ancient temple where the relic could be.</li>
        <p class="todo">Flesh this out completely, not a priority until other systems work.</p>
    </ul>
<h2>Protocols and Serialisation</h2>
    <h3>Overview</h3>
    <p>The player character sheet and login information will be transferred through HTML form submission,
    but after that a websocket channel is opened and a custom protocol begins.
    All websocket packet should be sent in binary format, and the first two bytes of the packet should determine
    what the message is and how it should be interpreted.
    Every message/state update in the game will have a specific single integer code to denote it.</p>
    <h3>Keepalive</h3>
    The client send a keepalive ping every few seconds to keep the TCP connection open.
    <h3>Player State</h3>
        <ul>
            <li>World Position</li>
            <li>Dead/Alive</li>
            <li>Resources</li>
            <li>Reputation</li>
            <li>Injuries</li>
        </ul>
    <h3>World State</h3>
    <p>
    World state would be the chances for certain encounters in certain regions.
    This remains server side completely, unless the client uncovers information
    to give them a hint of what sort of encounters are more likely and where.
    To the client, this would be a simple textual description, such as "The West Mountains are teeming with Monsters"
    but serverside this is reflected in the heat maps and weighted encounter type odds.
    </p>
    <h3>Encounters</h3>
    <p>
    The client asks the server for a random encounter at intervals, moving the character smoothly along the map.
    The server responds with whether there was an encounter or not and if there was, the character is snapped to the position of
    the encounter. The client side triggers the encounter UI, and then the client eventually responds with the same UID code
    but packet data to convey what decision they made for the encounter.
    The server needs to somehow know how to connect a decision for an encounter to the encounter and apply the state server side
    and then tell the client what to do next.
    </p>
    <h3>Prediction</h3>
    <p>
    Some things in the game, like movement can be predicted and interpolated.
    However, it's a turn based game where we'll be waiting on the results of
    random numbers a lot which cannot be predicted client side as most of the
    game is non-deterministic and relies on the server state.
    This simplifies the code a lot.
    </p>
    <h3>Localisation/Client Side Display</h3>
        <ul>
            <li>Encounters, player state, world state will all be handled through UID's on the network.
                Server side, it's raw numbers. Client side, it needs to show the right strings based on
                the UID for the state change.</li>
        </ul>
<h2>Robustness and Convenience</h2>
<h3>Handling a Disconnection</h3>
<h3>Vote Kicking</h3>
<h3>Vote Banning?</h3>
<h3>Malformed Input and Validation</h3>
</body>
</html>
